# 기초 문법

## 코드 작성법
* 세미콜론(semicolon)
  * js는 세미콜론을 선택적으로 사용가능
  * 세미콜론이 없으면 ASI에 의해 자동으로 세미콜론이 삽입됨
* 들여쓰기
  * js는 2칸 들여쓰기를 사용
  * 블럭은 if, for, 함수에서 중괄호{} 내부를 말함
  * js는 중괄호{}를 사용해 코드 블럭을 구분
* 주석
  * // : 한줄주석
  * /* */ : 여러줄 주석

## 변수와 식별자
* 식별자(identifier)
  * 식별자는 변수를 구분할 수 있는 변수명을 말함
  * 식별자는 반드시 문자, $, _로 시작
  * 대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작
  * 예약어 사용 불가
  * 카멜 케이스(camel Case) : 변수, 객체, 함수에 사용
  * 파스칼 케이스(Pascal Case) : 클래스, 생성자에 사용
  * 대문자 스네이크 케이스(SNAKE_CASE) : 상수(constants)에 사용
* 변수
  * let : 블록 스코프 지역 변수를 선언. 재할당 가능 & 재선언 불가능
  * const : 블록 스코프 읽기 전용 상수를 선언. 재할당 불가능 & 재선언 불가능
  * var : 변수를 선언. 재할당 가능 & 재선언 가능
  * 위 세가지 모두 선언 동시에 값을 초기화

## 데이터 타입
* 원시 타입 : Number, String, Boolean, undefined, null, Symbol
  * Number : 정수 or 실수형 숫자를 표현하는 자료형. NaN(Not-A-Number)은 숫자가 아님을 나타냄.
  * String : 문자열을 표현하는 자료형. 덧셈을 통해 문자열 붙일 수 있음. '\n'으로 줄바꿈 가능. Template Literal(`${name}`)을 사용하면 줄바꿈 가능하며 변수도 삽입가능.
  * null : 값이 없음을 의도적으로 표현할 때 사용하는 데이터 타입
  * undefined : 직접 값을 할당하지 않으면 자동으로 할당
  * Boolean : true와 false
* 참조 타입 : Objects, Array, Function

## 연산자
* 할당 연산자
  * `c += k` : c에 k를 더한다
  * `c -= k` : c에 k를 뺀다
  * `c *= k` : c에 k를 곱한다
  * `c++` : c에 1을 더한다
  * `c--` : c에 1을 뺀다
* 비교 연산자(<, > ...)
  * 피연산자들을 비교하고 결과값을 boolean으로 반환하는 연산자
* 동등 연산자(==)
  * 비교할 때 암묵적 타입변환을 통해 타입을 일치시킨 후 같은 값인지 비교
* 일치 연산자(===)
  * 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환. 암묵적 타입 변환이 발생하지 않음.
* 논리 연산자
  * && : AND
  * || : OR
  * ! : NOT
* 삼항 연산자
  * `조건문 ? 참일때 실행문 : 거짓일때 실행문`

## 조건문
* `if`, `else if`, `else`
  * 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓 판단
  * 조건은 소괄호 안에 작성
  * 실행할 코드는 중괄호 안에 작성
* `switch`
  * 조건 표현식의 결과값이 어느 값에 해당하는지 판별
  * 주로 특정 변수의 값에 따라 조건을 분기할 때 활용
  * 표현식의 결과값과 case문의 오른쪽 값을 비교
  * break 및 default 문은 선택적으로 사용가능

## 반복문
* `while(조건문)`
  * 조건문이 참이기만 하면 문장을 계속해서 수행
* `for([초기문];[조건문];[증감문])`
  * 특정한 조건이 거짓으로 판별될때 까지 반복
* `for _ in`
  * 객체의 속성을 순회할 때 사용. 배열도 순회가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장하지 않음.
* `for _ of`
  * 반복 가능한 객체를 순회할 때 사용.
  * 반복 가능한(iterable) 객체의 종류 : Array, Set, String 등

## 함수
* 함수의 정의
  * 함수 선언식 `function 함수명() {}`
  * 함수 표현식 `변수키워드 함수명 = function(){}`
  * 기본 인자 : 인자 작성시 '=' 문자 뒤 기본 인자 선언 가능 `변수키워드 함수명 = function (인자이름 = '인자이름'){}`
  * 매개변수 인자의 개수 불일치 허용
    * 매개변수보다 인자의 개수가 많을 경우
    * 매개변수보다 인자의 개수가 적을 경우 : 'undefined'로 처리
  * spread syntax (...) : 전개구문
    * 전개구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 배열의 경우는 요소, 함수의 경우는 인자로 확장
    * 배열과의 사용(배열 복사)
    ``` javascript
    let parts = ['shoulders', 'knee']
    let lyrics = ['head', ...parts, 'and', 'toes']
    // ['head', 'shoulders', 'knee', 'and', 'toes']
    ```
    * 함수와의 사용(Rest parameters) : 정해지지 않은 수의 매개변수를 배열로 받을 수 있음.

* 선언식과 표현식
  * 함수의 타입
    * 선언식 함수와 표현식 함수 모두 타임은 function으로 동일
  * 호이스팅
    * 선언식
      * 함수 선언식으로 정의한 함수는 var로 정의한 변수처럼 호이스팅이 발생
      * 즉, 함수 호출 이후에 선언해도 동작
    * 표현식
      * 반면 함수 표현식으로 선언한 함수는 함수 정의 전에 호출 시 에러 발생
      * 함수 표현식으로 정의된 함수는 변수로 평가되어 변수의 scope 규칙을 따름

* Arrow Function
  * Arrow Function(화살표 함수)
    * 함수를 비교적 간결하게 정의할 수 있는 문법
    * function 키워드와 중괄호를 이용한 구문을 짧게 사용하기 위해 탄생
      * function 키워드 생략가능
      * 함수의 매개변수가 하나 뿐이라면 매개변수의 '()' 생략 가능
      * 함수의 내용이 한 줄이라며 '{}'와 'return' 생략 가능
    * 화살표 함수는 항상 익명 함수 
      * '===' 함수 표현식에서만 사용가능
    ``` javascript
    const arrow1 = function (name) {
      return `hello, ${name}`
    }
    // function 키워드 삭제
    const arrow2 = (name) => {return `hello, ${name}`}
    // 인자가 1개일 경우에만 () 생략 가능
    const arrow3 = name => {return `hello, ${name}`}
    // 함수 바디가 return을 포함한 표현식이 1개일 정우 {}, return 생략가능
    const arrow4 = name => `hello, ${name}`
    ```
  * 즉시 실행함수(IIFE, Immediately Invoked Function Expression)
    * 선언과 동시에 실행되는 함수
    * 함수의 선언 끝에 '()'를 추가하여 선언되자 마자 실행하는 형태
    * '()'에 값을 넣어 인자로 넘겨줄 수 있음
    * 즉시 실행함수는 선언과 동시에 실행되기 때문에 같은 함수를 다시 호출할 수 없음. 그래서 초기화 부분에 많이 사용
    * 일회성 함수이므로 익명함수로 사용하는 것이 일반적
    ``` javascript
    (function(num) {return num ** 3}) // 8
    (num => num**3)(2) //8
    ```

## Array와 Object
* Array (배열)
  * 키와 속성들을 담고 있는 참조 타입의 객체
  * 순서를 보장하는 특징이 있음
  * 주로 대괄호'[]'를 이용하여 생성하고, 0을 포함한 양의 정수 인덱스로 특정 값에 접근 가능
  * 배열의 길이는 `array.length` 형태로 접근 가능
* 배열 메서드
  * `reverse` : 원본 배열의 요소들의 순서를 반대로 정렬
  * `push & pop` : 배열의 가장 뒤에 요소를 추가 또는 제거
  * `unshift&shift` : 배열의 가장 앞에 요소를 추가 또는 제거
  * `includes` : 배열에 특정 값이 존재하는지 판별 후 참/거짓 반환
  * `indexOf` : 배열에 특정 값이 존재하는지 반별 후 인덱스 반환. 없으면 -1 반환
  * `join` : 배열의 모든 요소를 구분자를 이용하여 연결. default = ','
  * `forEach`: 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행. 반환값 없음.
  ``` javascript
  array.forEach((element, index, array) => {
    // element : 배열의 요소
    // index : 배열 요소의 인덱스
    // array : 배열 자체
  })
  ```
  * `map`: 콜백함수의 반환값을 요소로 하는 새로운 배열 반환
  * `filter`: 콜백 함수의 반환 값이 참인 요소들만 모아서 새로운 배열을 반환
  * `reduce`: 콜백 함수의 반환 값들을 하나의 값에 누적 후 반환
  * `find`: 콜백함수의 반환 값이 참이면 해당 요소를 반환
  * `some`: 배열의 요소 중 하나라도 판별 함수를 통과하면 참을 반환
  * `entry`: 배열의 모든 요소가 판별 함수를 통과하면 참을 반환
* Object (객체)
  * 객체는 속성의 집합이며, 중괄호 내부에 key와 value의 쌍으로 표현
  * key
    * 문자열 타입만 가능
    * key이름에 띄어쓰기 등의 구분자가 있으면 따옴표로 묶어서 표현
  * value
    * 모든 타입(함수 포함) 가능
  * 객체 요소 접근
    * 점(.) 또는 대괄호([])로 가능
    * key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능
* 객체 관련 문법
  * 속성명 축약
    * 객체를 정의할 때 key와 할당하는 변수의 이름이 같으면 예시와 같이 축약 가능
  * 메서드명 축약
    * 메서드 선언시 function 키워드 생략 가능
  * 계산된 속성(computed property name)
    * 객체를 정의할 때 key의 이름을 표현식을 이용하여 동적으로 생성 가능
  * 구조 분해 할당
    * 배열 또는 객체를 분해하여 속성을 변수에 쉽게 할당할 수 있는 문법
  * spread syntax(...)
    * 배열과 마찬가지로 전개구문을 사용해 객체 내부에서 객체 전개 가능.
    * 얕은 복사에 활용 가능
* JSON(JavaScript Object Notation)
  * Key-Value 형태로 이루어진 자료 표기법
  * JavaScript의 Object와 유사한 구조를 가지고 있지만 Object는 그 자체로 타입이고, JSON은 형식이 있는 문자열
  * 즉, JSON을 Object로 사용하기 위해서는 변환 작업이 필요
  `const jsonToObj = JSON.parse(objToJson)`