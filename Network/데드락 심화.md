### 은행원 알고리즘

자원 할당 결정 전에 예상되는 모든 자원의 최대 할당량을 가지고 시뮬레이션 하여 safe state에 들 수 있는지 여부를 검사하여 교착상태의 가능성을 미리 조사하는 알고리즘

**CPU는 최소한 하나의 프로세스에게 할당해줄 만큼의 자원을 항상 보유하고 있어야한다**

EX)

시스템은 총 12개의 자원을 가지고있을때,

| t=t0 | 최대 자원 요청량 | 할당중인 자원량 | 남은 필요한 자원량 |
| --- | --- | --- | --- |
| p0 | 10 | 5 | 5 |
| p1 | 4 | 2 | 2 |
| p2 | 9 | 2 | 7 |

현재 할당 중인 자원량의 합 : 5+2+2 = 9

시스템이 가지고 있는 자원의 수 : 12

현재 상태에서 가용 자원량은 12 - 9 = 3

이제 가용자원을 어느 프로세스에게 할당해주냐에 따라 자원을 효율적으로 이용할 수 있다.

- 남은 가용자원 3개를 p1에게 할당 ⇒ 가용자원은 3 - 2 = 1
- p1의 작업이 끝나고 할당되어있던 자원 4개 반납 ⇒ 가용자원은 1 + 4 = 5
- 남은 가용자원을 p0에게 할당 ⇒ 가용자원은 5 - 5 = 0
- p0의 작업이 끝나고 할당되어 있던 자원 10개 반납 ⇒ 가용자원은 0 + 10 = 10
- 남은 가용자원을 p2에게 할당 ⇒ 가용자원은 10 - 7 = 3
- p2의 작업이 끝나고 할당되어 있던 자원 9개 반납 ⇒ 가용자원은 3 + 9 = 12

이렇게 p1-p2-p0 순서로 자원 할당시 Safe sequence를 만족.

- 단점
    - 미리 자원의 최대 요구량을 알아야하고, 할당할 수 있는 자원의 수가 일정해야함.

### 식사하는 철학자 문제

n명의 철학자들이 식탁에 둘러앉아 있다. 원형테이블을 공유하며, 테이블 중앙에는 밥이 있다.

또한 철학자들은 서로 상호 대화, 행동 일절 금지이다.

만약 배고파진다면 자신의 왼쪽에 있는 젓가락과 오른쪽에 있는 젓가락으로 식사를 할 수 있다.

하지만, 누가 이미 쓰고 있을 때는 젓가락을 사용하지 못한다.

젓가락은 한번에 한 쪽만 집을 수 있다.

젓가락을 2개 집게 되었을 경우 식사할 수 있다.

식사를 마치면 젓가락 2개를 모두 놓고 다시 생각한다.

교착과 기아가 생기지 않게 하는 방법을 생각해보자!

### 해결방안 1 세마포어 해결방법(Semaphore Solution)

각 젓가락 = 하나의 세마포어

Case 1)

- 모든 철학자가 다같이 배고파서 동시에 자신 왼쪽의 젓가락을 잡으면?
- 젓가락의 모든 원소는 0
- 오른쪽 젓가락을 영원히 잡을 수 없다.
- Deadlock 발생!!!!

Case 2)

- 가운데 사람이 껴서 양쪽의 사람만 밥을 먹는다
- 가운데 사람은 밥을 못먹는 기아가 생길 수도 있다.

Sol)

- 최대 4명의 철학자만 테이블에 동시에 앉을 수 있게한다.
- 한 철학자가 두 개를 모두 집을 수 있을때만 젓가락을 집도록 한다.
- **비대칭 해결안을 사용(홀수번째 철학자는 왼쪽 젓가락부터 집고, 짝수는 오른쪽부터 집어야한다.)**
- 단점
    - 코딩하기 힘들다
    - 정확성의 입증이 어렵다
    - 자발적 협력이 필요하다
    - 한 번의 실수가 모든 시스템에 치명적인 영향을 끼친다.

### 해결방안 2 모니터 해결방법(Monitor Solution)

- wait
    - 자원이 없으면 프로세스가 줄을 서서 기다리게 한다.
    - x.wait()을 호출한 프로세스는 다른 프로세스가 x.signal()을 호출하기 전까지 잠들게 된다.
- signal
    - 모니터에 접근하고 빠져나갈 때 signal 연산을 호출해서 기다리는 프로세스가 모니터에 접근하 수 있도록 한다.
    - x.signal()은 정확하게 하나의 잠이 든 프로세스를 깨운다.
    - 잠이 든 프로세스가 없으면 아무도 일어나지 않는다.